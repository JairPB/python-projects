Given an array of integers nums and an integer target, return indices of the two numbers such that they add up to target.
You may assume that each input would have exactly one solution, and you may not use the same element twice.
You can return the answer in any order.

# Solution:

class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        seen = {}  # Starts empty, but will fill during iteration
        for i, num in enumerate(nums):
            complement = target - num
            if complement in seen:  # Check ONLY against previously seen numbers
                return [seen[complement], i]  # Found a valid pair!
            seen[num] = i  # Add CURRENT number to dictionary for future checks

Key Concepts Explained Simply:
1. Dictionaries - Your Code's Memory
Think of a dictionary like a contact list on your phone:

Key = Person's name (in your code: the number from the array)
Value = Phone number (in your code: the position/index of that number)

pythonseen = {}  # Creates an empty dictionary
# As you loop, it fills up like this:
# {2: 0, 7: 1, 11: 2, 15: 3}
#  ↑   ↑
#  number: its position
Why use a dictionary? Because checking if something exists in a dictionary is super fast (instant lookup), unlike checking through a list which requires looking at every item.

2. The complement - Your Missing Piece
This is the brilliant insight of your solution!
pythoncomplement = target - num
Think of it like a puzzle: If the target is 9 and you're looking at the number 2, you ask yourself: "What number do I need to reach 9?" The answer is 7 (because 2 + 7 = 9). That's the complement!
Real-world analogy: If you need $9 and you have $2, you need to find someone with $7.

3. enumerate() - Getting Both Position and Value
pythonfor i, num in enumerate(nums):
enumerate() is like getting a numbered ticket at the deli counter. It gives you:

i = the position (index) in the array (0, 1, 2, 3...)
num = the actual value at that position (2, 7, 11, 15...)

Without enumerate:
pythonfor i in range(len(nums)):
    num = nums[i]  # You'd have to do this extra step
With enumerate: You get both at once! Much cleaner.

How Your Algorithm Works (Step-by-Step)
Let's trace through Example 1: nums = [2,7,11,15], target = 9:

------------------------------------------------------------------------------------------------|
Step,  i,  num,  complement,  Is complement in seen?,  seen dictionary,  Action                 |
------------------------------------------------------------------------------------------------|
1,     0,   2,        7,              No,              {} → {2: 0}      Add 2 to memory         |
2,     1,   7,        2,              Yes!             {2: 0}           Found it! Return [0, 1] |
------------------------------------------------------------------------------------------------|

Why it works: When you reach 7, you check "Have I seen 2 before?" Yes! So you know 2 (at index 0) + 7 (at index 1) = 9.

Why This Solution Is Smart
Time Complexity: O(n) - Very efficient!
You only look at each number once. That's as fast as it gets.
Space Complexity: O(n) - Uses extra memory
The dictionary can grow to hold all numbers (worst case).
The "Check Before Adding" Pattern
This is crucial:
pythonif complement in seen:      # ← Check FIRST
    return [seen[complement], i]
seen[num] = i               # ← Add AFTER
Why this order matters: You don't want to accidentally find the same number twice. By checking before adding, you only compare against previous numbers.

Key Python Syntax You're Using

Dictionary lookup: complement in seen - checks if a key exists
Dictionary access: seen[complement] - gets the value for that key
Dictionary assignment: seen[num] = i - stores a new key-value pair
Multiple return values: return [seen[complement], i] - returns a list with two indices
Type hints: List[int] tells others what type of data to expect


Common Mistakes This Solution Avoids
❌ Bad approach: Using two nested loops to check every pair
python# This would be O(n²) - much slower!
for i in range(len(nums)):
    for j in range(i+1, len(nums)):
        if nums[i] + nums[j] == target:
            return [i, j]
✅ Your approach: Single loop with dictionary lookup - O(n)
