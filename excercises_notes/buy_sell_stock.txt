class Solution:
    def maxProfit(self, prices: List[int]) -> int:
        min_price = prices[0]
        max_profit = 0

        for price in prices:
            if price < min_price:
                min_price = price

            profit = price - min_price
            if profit > max_profit:
                    max_profit = profit

        return max_profit


--ðŸ§ Key Concepts Learned--

1. Tracking Algorithm Pattern
Instead of storing ALL values, track only what you need:

Less efficient: Store everything, then search
More efficient: Update "best so far" as you go

Real-world analogy: Like remembering only the lowest gas price you've seen while driving, not every single price.
2. Two-Variable Tracking
This problem needs TWO pieces of information:

min_price - Lowest price seen so far (best time to buy)
max_profit - Highest profit found so far (our answer)

3. Single Pass Algorithm
You only need ONE loop through the data:
pythonfor each price:
    1. Update min_price if current is lower
    2. Calculate potential profit (current - min)
    3. Update max_profit if this profit is better
4. Time vs Space Efficiency

Storing all profits: O(n) extra space
Tracking best profit: O(1) constant space
Both use O(n) time, but tracking is better!

ðŸ’¡ Problem-Solving Strategy

Understand the constraint: Must buy BEFORE selling
Ask the right questions:

What's the cheapest buying opportunity so far?
What's my profit if I sell today?

Optimize: Don't save unnecessary data
Handle edge cases: What if prices only go down? (return 0)
